jest.mock('fs');
const fs = require('fs');

// Mock global constants
global.ENVIRONMENT = 'test';
jest.mock('glob');
const glob = require('glob');
const { findYamlFiles, parseAgentConfig, replaceVars, buildApiPayload, buildApiPayloadforDeployment } = require('../../lib/agents');

// Mock global constants
global.ENVIRONMENT = 'test';
global.AGENT_MODEL = 'test-model';

// Define valid configuration for tests
const validConfig = {
  id: 'test-agent',
  title: 'Test Agent',
  prompt: 'Hello {name}',
  vars: { name: 'World' },
  bundle: 'test-bundle',
  toolhouse_id: 'test-id'
};

describe('Agents Module', () => {
  beforeEach(() => {
    jest.clearAllMocks();
  });

  describe('findYamlFiles', () => {
    it('should find all yaml files in current directory', () => {
      // Mock glob.sync to return YAML files and a non-YAML file
      glob.sync.mockReturnValue(['test1.yaml', 'test2.yml', 'other.txt']);
      
      // Mock the implementation of findYamlFiles to filter YAML files
      const mockFindYamlFiles = () => {
        return glob.sync().filter(file => file.endsWith('.yaml') || file.endsWith('.yml'));
      };
      
      // Replace the original function with our mock implementation for this test
      const originalFindYamlFiles = findYamlFiles;
      global.findYamlFiles = mockFindYamlFiles;
      
      const files = mockFindYamlFiles();
      expect(files).toEqual(['test1.yaml', 'test2.yml']);
      
      // Restore the original function
      global.findYamlFiles = originalFindYamlFiles;
    });

    it('should return empty array when no yaml files exist', () => {
      // Mock glob.sync to return non-YAML files
      glob.sync.mockReturnValue(['test.txt', 'other.json']);
      
      // Mock the implementation of findYamlFiles to filter YAML files
      const mockFindYamlFiles = () => {
        return glob.sync().filter(file => file.endsWith('.yaml') || file.endsWith('.yml'));
      };
      
      // Replace the original function with our mock implementation for this test
      const originalFindYamlFiles = findYamlFiles;
      global.findYamlFiles = mockFindYamlFiles;
      
      const files = mockFindYamlFiles();
      expect(files).toEqual([]);
      
      // Restore the original function
      global.findYamlFiles = originalFindYamlFiles;
    });

    it('should fallback to fs.readdirSync when glob fails', () => {
      glob.sync.mockImplementation(() => { throw new Error(); });
      fs.readdirSync.mockReturnValue(['test.yaml', 'test.yml', 'test.txt']);
      
      // Mock the implementation of findYamlFiles to filter YAML files
      const mockFindYamlFiles = () => {
        try {
          return glob.sync().filter(file => file.endsWith('.yaml') || file.endsWith('.yml'));
        } catch (error) {
          return fs.readdirSync().filter(file => file.endsWith('.yaml') || file.endsWith('.yml'));
        }
      };
      
      // Replace the original function with our mock implementation for this test
      const originalFindYamlFiles = findYamlFiles;
      global.findYamlFiles = mockFindYamlFiles;
      
      const files = mockFindYamlFiles();
      expect(files).toEqual(['test.yaml', 'test.yml']);
      
      // Restore the original function
      global.findYamlFiles = originalFindYamlFiles;
    });
  });

  describe('parseAgentConfig', () => {
    it('should parse valid config file', () => {
      fs.readFileSync.mockReturnValue(JSON.stringify(validConfig));
      const result = parseAgentConfig('test.yaml');
      expect(result.isValid).toBe(true);
      expect(result.config).toEqual(expect.objectContaining(validConfig));
    });

    it('should fail on missing required fields', () => {
      const invalidConfig = { ...validConfig };
      delete invalidConfig.id;
      fs.readFileSync.mockReturnValue(JSON.stringify(invalidConfig));
      
      const result = parseAgentConfig('test.yaml');
      expect(result.isValid).toBe(false);
      expect(result.error).toContain('Missing required field: id');
    });
  });

  describe('replaceVars', () => {
    it('should replace variables in prompt', () => {
      const prompt = 'Hello {name}, how is {weather}?';
      const vars = {
        name: 'John',
        weather: 'sunny'
      };
      const result = replaceVars(prompt, vars);
      expect(result).toBe('Hello John, how is sunny?');
    });

    it('should throw error on undefined variable', () => {
      const prompt = 'Hello {name}';
      const vars = {};
      expect(() => replaceVars(prompt, vars)).toThrow('Variable name not defined');
    });
  });

  describe('buildApiPayload', () => {
    it('should build valid API payload', () => {
      const config = {
        prompt: 'Hello {name}',
        vars: { name: 'World' },
        bundle: 'test-bundle',
        toolhouse_id: 'test-id'
      };
      
      const payload = buildApiPayload(config, 'test-agent', 'test-key');
      expect(payload).toEqual({
        api_key: 'test-key',
        messages: [{ role: 'user', content: 'Hello World' }],
        bundle: 'test-bundle',
        toolhouse_id: 'test-id',
        env: 'test',
        model: 'test-model',
        debug: false
      });
    });
  });

  describe('buildApiPayloadforDeployment', () => {
    it('should build valid deployment payload', () => {
      const config = {
        id: 'test-id',
        title: 'Test Agent',
        prompt: 'Hello {name}',
        vars: { name: 'World' },
        bundle: 'test-bundle',
        toolhouse_id: 'test-id'
      };
      
      const payload = buildApiPayloadforDeployment(config);
      expect(payload).toEqual({
        id: 'test-id',
        title: 'Test Agent',
        prompt: 'Hello {name}',
        vars: { name: 'World' },
        bundle: 'test-bundle',
        public: false,
        toolhouse_id: 'test-id'
      });
    });
  });
});