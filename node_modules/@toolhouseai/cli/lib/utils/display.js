const chalk = require("chalk");
const boxen = require("boxen");

// Create a fancy box for output
function createBox(content, options = {}) {
  const boxOptions = {
    padding: 1,
    margin: 1,
    borderColor: options.borderColor || "cyan",
    borderStyle: "round",
  };

  return boxen(content, boxOptions);
}

// Process streaming response
async function processStream(response, agentName) {
  console.log(
    chalk.cyan(`\n━━━━ Stream output for ${chalk.bold(agentName)} ━━━━`)
  );

  let accumulatedText = "";

  try {
    // Use Node.js stream handling instead of the web Streams API
    return new Promise((resolve, reject) => {
      response.body.on("data", (chunk) => {
        // Convert Buffer to string
        const textChunk = chunk.toString("utf-8");
        accumulatedText += textChunk;

        // Print the chunk immediately
        process.stdout.write(textChunk);
      });

      response.body.on("end", () => {
        console.log(
          chalk.cyan(`\n━━━━ End of stream for ${chalk.bold(agentName)} ━━━━\n`)
        );
        resolve(accumulatedText);
      });

      response.body.on("error", (error) => {
        console.error(chalk.red(`\nError processing stream: ${error.message}`));
        reject(error);
      });
    });
  } catch (error) {
    console.error(chalk.red(`\nError processing stream: ${error.message}`));
    return accumulatedText;
  }
}

// Helper to ensure consistent formatting of messages
function formatErrorMessage(message) {
  return chalk.red(`Error: ${message}`);
}

function formatSuccessMessage(message) {
  return chalk.green(message);
}

function formatWarningMessage(message) {
  return chalk.yellow(`Warning: ${message}`);
}

function formatInfoMessage(message) {
  return chalk.cyan(message);
}

function formatErrorBox(message, details = {}) {
  const content =
    `${chalk.bold("Error")}` +
    `\n\n` +
    `${chalk.red(message)}\n` +
    `${Object.entries(details)
      .map(
        ([key, value]) =>
          `${chalk.red(key)} ${chalk.red("→")} ${chalk.dim(value)}`
      )
      .join("\n")}`;

  return (
    "\n" +
    createBox(content, {
      borderColor: "red",
      padding: 1,
      margin: 1,
      borderStyle: "single",
    })
  );
}

function formatSuccessBox(title, params = {}, nextSteps = {}) {
  const message = [];
  message.push(`${chalk.bold(title)}`);

  if (params) {
    const paramsKeys = Object.keys(params);

    if (paramsKeys.length > 0) {
      message.push("");
      const maxLength = Math.max(...paramsKeys.map((k) => k.length));
      paramsKeys.forEach((key, i) =>
        message.push(
          `${chalk.dim(key.padEnd(maxLength))}  ${
            i % 2 === 0
              ? chalk.cyan.bold(params[key])
              : chalk.yellow.bold(params[key])
          }`
        )
      );
    }
  }

  if (nextSteps) {
    const nextStepsKeys = Object.keys(nextSteps);

    if (nextStepsKeys.length > 0) {
      message.push("\n");
      message.push(
        chalk.bold(
          nextStepsKeys.length === 1
            ? "Next suggested action"
            : "Next suggested actions"
        )
      );
      message.push("");
      nextStepsKeys.forEach((key, i) => {
        message.push(`${chalk.dim("┌")} ${chalk.green(nextSteps[key])}`);
        message.push(`${chalk.dim("└")} ${chalk.dim(key)}`);
        if (i + 1 < nextStepsKeys.length) {
          message.push(``);
        }
      });
    }
  }

  return (
    "\n" +
    createBox(message.join("\n"), {
      borderColor: "green",
      padding: 1,
      margin: 1,
      borderStyle: "double",
    })
  );
}

module.exports = {
  createBox,
  processStream,
  formatErrorMessage,
  formatSuccessMessage,
  formatWarningMessage,
  formatInfoMessage,
  formatSuccessBox,
  formatErrorBox,
};
